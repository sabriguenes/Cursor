---
description: TypeScript and React best practices
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: false
---

# TypeScript & React Standards

You are a TypeScript/React expert following modern best practices.

## TypeScript Fundamentals

### Type Definitions
```typescript
// Prefer interfaces for objects
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

// Use types for unions, intersections, utilities
type Status = 'pending' | 'active' | 'inactive';
type UserWithRole = User & { role: Role };
```

### Strict Mode
Always enable strict mode in `tsconfig.json`:
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true
  }
}
```

### Avoid `any`
```typescript
// ❌ Bad
function process(data: any) { ... }

// ✅ Good
function process<T extends Record<string, unknown>>(data: T) { ... }

// ✅ Also good - be specific
function process(data: UserInput) { ... }
```

### Utility Types
```typescript
// Partial - all properties optional
type UpdateUser = Partial<User>;

// Pick - select properties
type UserPreview = Pick<User, 'id' | 'name'>;

// Omit - exclude properties
type CreateUser = Omit<User, 'id' | 'createdAt'>;

// Record - typed object
type UserMap = Record<string, User>;
```

## React Patterns

### Functional Components
```typescript
interface ButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

export function Button({
  variant = 'primary',
  size = 'md',
  disabled = false,
  onClick,
  children,
}: ButtonProps) {
  return (
    <button
      className={cn(variants[variant], sizes[size])}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

### Hooks

```typescript
// Custom hook pattern
function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);

  return { user, loading, error };
}
```

### State Management (Zustand)
```typescript
import { create } from 'zustand';

interface AuthStore {
  user: User | null;
  isAuthenticated: boolean;
  login: (credentials: Credentials) => Promise<void>;
  logout: () => void;
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  isAuthenticated: false,
  login: async (credentials) => {
    const user = await authApi.login(credentials);
    set({ user, isAuthenticated: true });
  },
  logout: () => set({ user: null, isAuthenticated: false }),
}));
```

## Styling (Tailwind + shadcn/ui)

### Component Styling
```typescript
import { cn } from '@/lib/utils';

interface CardProps {
  className?: string;
  children: React.ReactNode;
}

export function Card({ className, children }: CardProps) {
  return (
    <div className={cn(
      'rounded-lg border bg-card p-6 shadow-sm',
      className
    )}>
      {children}
    </div>
  );
}
```

### Avoid Inline Styles
```typescript
// ❌ Bad
<div style={{ marginTop: 16, padding: 8 }}>

// ✅ Good
<div className="mt-4 p-2">
```

## File Structure

```
src/
├── app/                    # Next.js App Router
│   ├── (auth)/            # Route groups
│   ├── api/               # API routes
│   └── layout.tsx
├── components/
│   ├── ui/                # Reusable primitives
│   └── features/          # Feature-specific
├── hooks/                 # Custom hooks
├── lib/                   # Utilities
├── stores/                # Zustand stores
└── types/                 # Shared types
```

## Error Handling

```typescript
// API calls with proper error handling
async function fetchData<T>(url: string): Promise<T> {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new ApiError(
      `Request failed: ${response.status}`,
      response.status
    );
  }
  
  return response.json();
}
```

## Performance

- Use `React.memo` for expensive components
- Use `useMemo` for expensive calculations
- Use `useCallback` for stable function references
- Lazy load routes and heavy components
- Avoid unnecessary re-renders with proper deps arrays
